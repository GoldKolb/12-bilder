<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>360° Schmuck</title>
  <style>
    body {
      margin: 0;
      background-color: black;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }

    canvas {
      cursor: default;
    }
  </style>
</head>
<body>
  <canvas id="viewer" width="600" height="600"></canvas>

  <script>
    const canvas = document.getElementById('viewer');
    const ctx = canvas.getContext('2d');

    const totalImages = 12;
    const images = [];
    let currentFrame = 0;
    let isDragging = false;
    let lastX = 0;
    let autoRotate = true;
    let inactivityTimer;
    let lastRotateTime = 0;

    function preloadImages(callback) {
      let loaded = 0;
      for (let i = 1; i <= totalImages; i++) {
        const img = new Image();
        const number = i < 10 ? '0' + i : i;
        img.src = 'EinzelA' + number + '.JPG'; // Großes JPG hier beibehalten
        img.onload = function () {
          loaded++;
          if (loaded === totalImages) {
            callback();
          }
        };
        images.push(img);
      }
    }

    function drawFrame(index) {
      const img = images[index];
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Proportional skalieren und mittig platzieren
      const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
      const imgWidth = img.width * scale;
      const imgHeight = img.height * scale;
      const x = (canvas.width - imgWidth) / 2;
      const y = (canvas.height - imgHeight) / 2;

      ctx.drawImage(img, x, y, imgWidth, imgHeight);
    }

    function rotate(timestamp) {
      if (!lastRotateTime) lastRotateTime = timestamp;

      if (autoRotate && timestamp - lastRotateTime > 100) { // 100ms = 10fps
        currentFrame = (currentFrame + 1) % totalImages;
        drawFrame(currentFrame);
        lastRotateTime = timestamp;
      }

      requestAnimationFrame(rotate);
    }

    function resetInactivityTimer() {
      clearTimeout(inactivityTimer);
      autoRotate = false;
      inactivityTimer = setTimeout(function () {
        autoRotate = true;
      }, 5000);
    }

    canvas.addEventListener('mousedown', function (e) {
      isDragging = true;
      lastX = e.clientX;
      resetInactivityTimer();
    });

    window.addEventListener('mouseup', function () {
      isDragging = false;
    });

    canvas.addEventListener('mousemove', function (e) {
      if (isDragging) {
        const deltaX = e.clientX - lastX;
        if (Math.abs(deltaX) > 5) {
          currentFrame = (currentFrame - Math.sign(deltaX) + totalImages) % totalImages;
          drawFrame(currentFrame);
          lastX = e.clientX;
          resetInactivityTimer();
        }
      }
    });

    canvas.addEventListener('touchstart', function (e) {
      isDragging = true;
      lastX = e.touches[0].clientX;
      resetInactivityTimer();
    });

    canvas.addEventListener('touchend', function () {
      isDragging = false;
    });

    canvas.addEventListener('touchmove', function (e) {
      if (isDragging) {
        const deltaX = e.touches[0].clientX - lastX;
        if (Math.abs(deltaX) > 5) {
          currentFrame = (currentFrame - Math.sign(deltaX) + totalImages) % totalImages;
          drawFrame(currentFrame);
          lastX = e.touches[0].clientX;
          resetInactivityTimer();
        }
      }
    });

    preloadImages(function () {
      drawFrame(currentFrame);
      requestAnimationFrame(rotate);
    });
  </script>
</body>
</html>
